// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel MoveParticles
#pragma kernel UpdateDensity
#pragma kernel UpdatePressure
#pragma kernel ComputeForces

#define NUM_OF_THREADS 16


// Particle properties
RWStructuredBuffer<float3> positions;
RWStructuredBuffer<float3> velocities;
RWStructuredBuffer<float> pressures;
RWStructuredBuffer<float> densities;
RWStructuredBuffer<float3> forces;


int numOfParticles;

float deltaTime;
float3 down;

// Constants
float smoothingLength;
float molarMass;
float particleSize;
float gravitationalConstant;
float3 boundsPosition;
float3 boundsSize;
float collisionDamping;
float stiffnessConstant;
float restingDensity;
float viscosityCoefficient;


float SmoothingKernel(float smoothingLength, float distance)
{
    float q = distance / smoothingLength;
    float sigma = 315.0f / (64.0f * 3.14159 * pow(smoothingLength, 9));
    if (q >= 0 && q <= 1)
    {
        return sigma * pow((smoothingLength * smoothingLength - distance * distance), 3);
    }
    return 0;
}

float PressureKernelGradient(float smoothingLength, float distance)
{
    float q = distance / smoothingLength;
    if (q >= 0 && q <= 1)
    {
        return -45.0f / (3.14159 * pow(smoothingLength, 6)) * pow(1 - q, 2);
    }
    return 0;
}

float ViscosityKernelLaplacian(float smoothingLength, float distance)
{
    float q = distance / smoothingLength;
    if (q >= 0 && q <= 1)
    {
        return 45.0f / (3.14159 * pow(smoothingLength, 6)) * (1 - q);
    }
    return 0;
}

float3 ComputeViscosityForce(int i, int j, float distance)
{
    float3 velocityDiff = velocities[j] - velocities[i];
    float laplacian = ViscosityKernelLaplacian(smoothingLength, distance);
    return viscosityCoefficient * (velocityDiff / densities[j]) * laplacian;
}

float PressureEquation(float density)
{
    return stiffnessConstant * (density - restingDensity); //P = k(p - p0)
}

void ResloveBoundsCollision(float3 pos, float3 vel, int i)
{
    {
        float3 halfBoundsSize = boundsSize / 2;

        if (pos.x - particleSize < boundsPosition.x - halfBoundsSize.x)
        {
            pos.x = boundsPosition.x - halfBoundsSize.x + particleSize;
            vel.x *= -collisionDamping;
        }
        else if (pos.x + particleSize > boundsPosition.x + halfBoundsSize.x)
        {
            pos.x = boundsPosition.x + halfBoundsSize.x - particleSize;
            vel.x *= -collisionDamping;
        }

        if (pos.y - particleSize < boundsPosition.y - halfBoundsSize.y)
        {
            pos.y = boundsPosition.y - halfBoundsSize.y + particleSize;
            vel.y *= -collisionDamping;
        }
        else if (pos.y + particleSize > boundsPosition.y + halfBoundsSize.y)
        {
            pos.y = boundsPosition.y + halfBoundsSize.y - particleSize;
            vel.y *= -collisionDamping;
        }

        if (pos.z - particleSize < boundsPosition.z - halfBoundsSize.z)
        {
            pos.z = boundsPosition.z - halfBoundsSize.z + particleSize;
            vel.z *= -collisionDamping;
        }
        else if (pos.z + particleSize > boundsPosition.z + halfBoundsSize.z)
        {
            pos.z = boundsPosition.z + halfBoundsSize.z - particleSize;
            vel.z *= -collisionDamping;
        }
        
        positions[i] = pos;
        velocities[i] = vel;
    }
}

[numthreads(NUM_OF_THREADS, 1, 1)]
void MoveParticles(uint3 id : SV_DispatchThreadID)
{
    velocities[id.x] += forces[id.x] * deltaTime;
    velocities[id.x] += down * gravitationalConstant * deltaTime; // Apply gravity

            // Update positions
    positions[id.x] += velocities[id.x] * deltaTime;
    
    ResloveBoundsCollision(positions[id.x], velocities[id.x], id.x);
}

[numthreads(NUM_OF_THREADS,1,1)]
void UpdateDensity(uint3 id : SV_DispatchThreadID)
{

    float density = 0;
    
    for (int i = 0; i < numOfParticles; i++)
    {
        float3 d = (positions[id.x] - positions[i]);
        
        float distance = sqrt((d.x * d.x) + (d.y * d.y) + (d.z * d.z));
        
        if (distance < smoothingLength)
        {
            density += molarMass * SmoothingKernel(smoothingLength, distance);
        }
        
    }         
    densities[id.x] = density;
}


[numthreads(NUM_OF_THREADS, 1, 1)]
void UpdatePressure(uint3 id : SV_DispatchThreadID)
{
    uint particleIndex = id.x;
    pressures[particleIndex] = PressureEquation(densities[particleIndex]);
}

[numthreads(NUM_OF_THREADS, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID)
{
    float3 force = float3(0, 0, 0);
    
    for (int i = 0; i < numOfParticles; i++)
    {
        if(id.x != i)
        {
            float3 d = (positions[id.x] - positions[i]);
        
            float distance = sqrt((d.x * d.x) + (d.y * d.y) + (d.z * d.z));
        
            if (distance < smoothingLength)
            {
                float3 dir = (positions[i] - positions[id.x]);
                float3 norm = sqrt((dir.x * dir.x) + (dir.y * dir.y) + (dir.z * dir.z));
                
                dir.x = dir.x / norm.x;
                dir.y = dir.y / norm.y;
                dir.z = dir.z / norm.z;

                        // Pressure force
                float pressureForce = -(pressures[id.x] + pressures[i]) / (2.0f * densities[i]) * PressureKernelGradient(smoothingLength, distance);
                force += dir * pressureForce;

                        // Viscosity force
                force += ComputeViscosityForce(id.x, i, distance);
            }
        }
        
    }
    forces[id.x] = force;
    
}
